#include <hxGCInternal.h>

#ifdef INTERNAL_GC

#include <hxObject.h>

#include <map>
#include <vector>
#include <set>

#define SIZE_MASK    0x3fffffff


static bool sgAllocInit = 0;
static bool sgInternalEnable = true;

int sgAllocedSinceLastCollect = 0;


template<typename T>
struct QuickVec
{
	QuickVec() : mPtr(0), mAlloc(0), mSize(0) { } 
	inline void push(T inT)
	{
		if (mSize+1>=mAlloc)
		{
			mAlloc = 10 + (mSize*3/2);
			mPtr = (T *)realloc(mPtr,sizeof(T)*mAlloc);
		}
		mPtr[mSize++]=inT;
	}
	inline T pop()
	{
		return mPtr[--mSize];
	}
   inline void qerase(int inPos)
   {
      --mSize;
      mPtr[inPos] = mPtr[mSize];
   }
	inline bool empty() const { return !mSize; }
	inline int next()
	{
		if (mSize+1>=mAlloc)
		{
			mAlloc = 10 + (mSize*3/2);
			mPtr = (T *)realloc(mPtr,sizeof(T)*mAlloc);
		}
		return mSize++;
	}
	inline int size() const { return mSize; }
	inline T &operator[](int inIndex) { return mPtr[inIndex]; }

	int mAlloc;
	int mSize;
	T *mPtr;
};


// --- hxInternalFinalizer -------------------------------

typedef QuickVec<hxInternalFinalizer *> FinalizerList;

FinalizerList *sgFinalizers = 0;

hxInternalFinalizer::hxInternalFinalizer(hxObject *inObj)
{
	mUsed = false;
	mValid = true;
	mObject = inObj;
	mFinalizer = 0;
	sgFinalizers->push(this);
}

void hxInternalFinalizer::Detach()
{
	mValid = false;
}

void RunFinalizers()
{
	FinalizerList &list = *sgFinalizers;
	int idx = 0;
	while(idx<list.size())
	{
		hxInternalFinalizer *f = list[idx];
		if (!f->mValid)
			list.qerase(idx);
		else if (!f->mUsed)
		{
			if (f->mFinalizer)
				f->mFinalizer(f->mObject);
			list.qerase(idx);
			delete f;
		}
		else
		{
			f->mUsed = false;
			idx++;
		}
	}
}

// --- AllocInfo -----------------



typedef QuickVec<struct AllocInfo *> AllocInfoList;

struct AllocInfo
{
   static void Init()
   {
      mActivePointers = new AllocInfoList();
   }

   inline void Unlink()
   {
      //sTotalSize -= (mSize & SIZE_MASK);
      sTotalObjs--;
   }

   inline void Link()
   {
      mActivePointers->push(this);
      //sTotalSize += (mSize & SIZE_MASK);
      sTotalObjs++;
   }

   static AllocInfo *Create(int inSize)
   {
      AllocInfo *result = (AllocInfo *)malloc( inSize + sizeof(AllocInfo) );
      memset(result,0,inSize+sizeof(AllocInfo));
      result->mSize = inSize;
      result->Link();
      return result;
   }

   // We will also use mSize for the mark-bit.
   // If aligment means that there are 4 bytes spare after size, then we
   //  will use those instead.
   // For strings generated by the linker, rather than malloc, this last int
   //  will be 0xffffffff
   int        mSize;

   static unsigned int sTotalSize;
   static unsigned int sTotalObjs;

   static AllocInfoList *mActivePointers;
};

AllocInfoList *AllocInfo::mActivePointers = 0;
unsigned int AllocInfo::sTotalSize = 0;
unsigned int AllocInfo::sTotalObjs = 0;




#define POOL_BIN_SHIFT   3
#define POOL_BIN         (1<<POOL_BIN_SHIFT)
#define POOL_COUNT       32
#define MAX_POOLED       (POOL_COUNT<<POOL_BIN_SHIFT)

static AllocInfoList sgFreePool[POOL_COUNT];
static int sgMaxPool[POOL_COUNT];

void *hxInternalNew( int inSize )
{
   AllocInfo *data = 0;

   inSize = (inSize + POOL_BIN -1 ) & (~(POOL_BIN-1));

   sgAllocedSinceLastCollect+=inSize;

   //printf("hxInternalNew %d\n", inSize);
   if (!sgAllocInit)
   {
      sgAllocInit = true;
      AllocInfo::Init();
      sgFinalizers = new FinalizerList();
      sgMaxPool[0] = 0;
      // Up to 500k per bin ...
      for(int i=1;i<POOL_COUNT;i++)
         sgMaxPool[i] = 500000 / (i<<POOL_BIN_SHIFT);
   }
   // First run, we can't be sure the pool has initialised - but now we can.
   else if (inSize < MAX_POOLED )
   {
      int bin =  inSize >> POOL_BIN_SHIFT;
      AllocInfoList &spares = sgFreePool[bin];
      if (!spares.empty())
      {
          data = spares.pop();
          data->Link();
      }
   }

   if (!data)
      data = AllocInfo::Create(inSize);
   else
      memset(data+1,0,inSize);

   return data + 1;
}



void hxInternalCollect()
{
   if (!sgAllocInit || !sgInternalEnable)
		return;

   //printf("New Bytes %d/%d\n", sgAllocedSinceLastCollect, AllocInfo::sTotalSize );
   //if (sgAllocedSinceLastCollect*4 < AllocInfo::sTotalSize)
      //return;

   sgAllocedSinceLastCollect= 0;


   hxGCMarkNow();

	RunFinalizers();

   // And sweep ...
   int deleted = 0;
   int retained = 0;

   int &size = AllocInfo::mActivePointers->mSize;
   AllocInfo **info = AllocInfo::mActivePointers->mPtr;
   int idx = 0;
   while(idx<size)
   {
      AllocInfo *data = info[idx];
      int &flags = ( (int *)(data+1) )[-1];
      if ( !(flags & HX_GC_MARKED) )
      {
          data->Unlink();
          AllocInfo::mActivePointers->qerase(idx);

          int bin = data->mSize >> POOL_BIN_SHIFT;
          if ( bin < POOL_COUNT )
          {
               AllocInfoList &pool = sgFreePool[bin];
               if (pool.size()<sgMaxPool[bin])
                  pool.push(data);
               else
                  free(data);
          }
          else
             free(data);
          deleted++;
      }
      else
      {
           flags ^= HX_GC_MARKED;
           retained++;
           idx++;
      }
   }

   //printf("Objs freed %d/%d)\n", deleted, retained);
}



void hxInternalEnableGC(bool inEnable)
{
   sgInternalEnable = inEnable;
}


void *hxInternalRealloc(void *inData,int inSize)
{
   if (inData==0)
      return hxInternalNew(inSize);

   AllocInfo *data = ((AllocInfo *)(inData) ) -1;
   int s = data->mSize & SIZE_MASK;

   void *new_data = hxInternalNew(inSize);

   int min_size = s < inSize ? s : inSize;

   memcpy(new_data, inData, min_size );

   return new_data;
}


#endif // if INTERNAL_GC
