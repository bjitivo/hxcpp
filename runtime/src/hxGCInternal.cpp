#include <hxGCInternal.h>

#ifdef INTERNAL_GC

#include <hxObject.h>

#include <map>
#include <vector>
#include <set>

#define SIZE_MASK    0x3fffffff


static bool sgAllocInit = 0;
static bool sgInternalEnable = true;


struct AllocInfo
{
   void InitHead()
   {
      mSize = 0;
      mFinalizer = 0;
      mNext = 0;
      mPrev = 0;
   }

   inline void Unlink()
   {
      mPrev->mNext = mNext;
      if (mNext)
        mNext->mPrev = mPrev;
      sTotalSize -= (mSize & SIZE_MASK);
      sTotalObjs--;
      if (mFinalizer)
      {
         hxObject *obj = (hxObject *)(this +1);
         mFinalizer(obj);
      }
   }

   inline void Link()
   {
      mNext = sHead.mNext;
      mPrev = &sHead;
      if (mNext)
         mNext->mPrev = this;
      sHead.mNext = this;
      mFinalizer = 0;
      sTotalSize += (mSize & SIZE_MASK);
      sTotalObjs++;
   }

   static AllocInfo *Create(int inSize)
   {
      AllocInfo *result = (AllocInfo *)malloc( inSize + sizeof(AllocInfo) );
      memset(result,0,inSize+sizeof(AllocInfo));
      result->mSize = inSize;
      result->Link();
      return result;
   }

   AllocInfo *Realloc(int inSize)
   {
      AllocInfo *new_info = (AllocInfo *)malloc( inSize + sizeof(AllocInfo) );
      int s = mSize & SIZE_MASK;
      int min_size = s < inSize ? s : inSize;
      memcpy(new_info, this, min_size + sizeof(AllocInfo) ); 
      if (inSize>s)
         memset(((char *)new_info) + s + sizeof(AllocInfo), 0, inSize-s ); 
      new_info->mSize = (mSize & ~SIZE_MASK) | inSize;
      sTotalSize += inSize-s;
      if (new_info->mNext)
         new_info->mNext->mPrev = new_info;
      if (new_info->mPrev)
         new_info->mPrev->mNext = new_info;
      free(this);
      return new_info;
   }
   
   finalizer  mFinalizer;
   AllocInfo  *mNext;
   AllocInfo  *mPrev;
   // We will also use mSize for the mark-bit.
   // If aligment means that there are 4 bytes spare after size, then we
   //  will use those instead.
   // For strings generated by the linker, rather than malloc, this last int
   //  will be 0xffffffff
   int        mSize;

   static AllocInfo sHead;
   static unsigned int sTotalSize;
   static unsigned int sTotalObjs;
};

AllocInfo AllocInfo::sHead;
unsigned int AllocInfo::sTotalSize = 0;
unsigned int AllocInfo::sTotalObjs = 0;

template<typename T>
struct QuickVec
{
	QuickVec() : mPtr(0), mAlloc(0), mSize(0) { } 
	inline void push(T inT)
	{
		if (mSize+1>=mAlloc)
		{
			mAlloc = 10 + (mSize*3/2);
			mPtr = (T *)realloc(mPtr,sizeof(T)*mAlloc);
		}
		mPtr[mSize++]=inT;
	}
	inline T pop()
	{
		return mPtr[--mSize];
	}
	inline bool empty() const { return !mSize; }
	inline int next()
	{
		if (mSize+1>=mAlloc)
		{
			mAlloc = 10 + (mSize*3/2);
			mPtr = (T *)realloc(mPtr,sizeof(T)*mAlloc);
		}
		return mSize++;
	}
	inline int size() const { return mSize; }
	inline T &operator[](int inIndex) { return mPtr[inIndex]; }

	int mAlloc;
	int mSize;
	T *mPtr;
};


typedef QuickVec<AllocInfo *> SparePointers;
#define POOL_SIZE 65
static SparePointers sgSmallPool[POOL_SIZE];



void *hxInternalNew( int inSize )
{
   AllocInfo *data = 0;

   //printf("hxInternalNew %d\n", inSize);
   if (!sgAllocInit)
   {
      sgAllocInit = true;
      AllocInfo::sHead.InitHead();
   }
   // First run, we can't be sure the pool has initialised - but now we can.
   else if (inSize < POOL_SIZE )
   {
      SparePointers &spares = sgSmallPool[inSize];
      if (!spares.empty())
      {
          data = spares.pop();
          data->Link();
      }
   }

   if (!data)
      data = AllocInfo::Create(inSize);
   else
      memset(data+1,0,inSize);

   return data + 1;
}



void hxInternalCollect()
{
   if (!sgAllocInit || !sgInternalEnable)
		return;

   hxGCMarkNow();

   // And sweep ...
   int deleted = 0;
   int retained = 0;
   AllocInfo *data = AllocInfo::sHead.mNext;
   while(data)
   {
      AllocInfo *next = data->mNext;
      int &flags = ( (int *)(data+1) )[-1];
      if ( !(flags & HX_GC_MARKED) )
      {
          data->Unlink();
          if ( (data->mSize & SIZE_MASK) <POOL_SIZE )
          {
               SparePointers &pool = sgSmallPool[data->mSize & SIZE_MASK];
               if (pool.size()<1000)
               {
                  pool.push(data);
                  data = 0;
               }
          }
          if (data)
             free(data);
          deleted++;
      }
      else
      {
           flags ^= HX_GC_MARKED;
           retained++;
      }
      data = next;
   }

   //printf("Objs freed %d/%d)\n", deleted, retained);
}


void hxInternalAddFinalizer(void *v, finalizer f)
{
   if (v)
   {
      AllocInfo *data = ((AllocInfo *)v) - 1;
      data->mFinalizer = f;
   }
}


void hxInternalEnableGC(bool inEnable)
{
   sgInternalEnable = inEnable;
}


void *hxInternalRealloc(void *inData,int inSize)
{
   if (inData==0)
      return hxInternalNew(inSize);

   AllocInfo *data = ((AllocInfo *)(inData) ) -1;

   AllocInfo *new_data = data->Realloc(inSize);

   return new_data+1;
}


#endif // if INTERNAL_GC
